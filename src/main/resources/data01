1.jdk 和 jre的区别

2.== 和equals的区别
    ==：比较的是两个字符串内存地址（堆内存）的数值是否相等，属于数值比较；
    equals()：比较的是两个字符串的内容，属于内容比较。

    == 的作用：
    　　基本类型：比较的就是值是否相同
    　　引用类型：比较的就是地址值是否相同
    equals 的作用:
        引用类型：默认情况下，比较的是地址值。
        不过，我们可以根据情况自己重写该方法。一般重写都是自动生成，比较对象的成员变量值是否相同
        以后进行字符串相等判断的时候都使用equals()。

3.两个对象的hashCode相同，则equals也为true么？
    两个对象用equals方法比较为true，它们的Hashcode值相同吗？
        答：不一定相同。正常情况下，因为equals()方法比较的就是对象在内存中的值，如果值相同，那么Hashcode值
        也应该相同。但是如果不重写hashcode方法，就会出现不相等的情况。
        两个对象equals相等，则它们的hashcode必须相等，反之则不一定。

4.final在java中的作用
    final关键字可以用于三个地方。用于修饰类、类属性和类方法。
    被final关键字修饰的类不能被继承，被final关键字修饰的类属性和类方法不能被覆盖（重写）；

5.java中Math.round(-1.5)用法    : -1
    Math.round()的原理是对传入的参数+0.5之后，再向下取整得到的数就是返回的结果，返回值为long型。
    这里的向下取整是说取比它小的第一个整数或者和它相等的整数。

    四舍五入的原理是在参数上加0.5然后做向下取整

    而“向下取整”实际上就是Math.floor()方法，注意Math.floor()返回的值为double类型的。
    类似地，还有一个Math.ceil()方法，表示“向上取整”，得到的结果是比参数大的第一个整数或者和参数相等的数，
    返回值也是double类型的。

6.String属于基础的数据类型么？
    String不是基本的数据类型，是final修饰的java类，java中的基本类型一共有8个，它们分别为：

    1 字符类型：byte，char
    2 基本整型：short，int，long
    3 浮点型：float，double
    4 布尔类型：boolean
    java 中String 是个对象，是引用类型 ;
    基础类型与引用类型的区别是:
        基础类型只表示简单的字符或数字，引用类型可以是任何复杂的数据结构 ，基本类型仅表示简单的数据类型，
        引用类型可以表示复杂的数据类型，还可以操作这种数据类型的行为 。

    java虚拟机处理基础类型与引用类型的方式是不一样的，对于基本类型，java虚拟机会为其分配数据类型实际占用
    的内存空间，而对于引用类型变量，他仅仅是一个指向堆区中某个实例的指针。

    基本数据类型和引用类型的区别主要在于基本数据类型是分配在栈上的，而引用类型是分配在堆上的

7.java中操作字符串都有哪些类型？

8.String str = "i"与String str = new String("i")一样么？
    str:str指向“i”的内存地址
    str：内存中重新分配一块区域存储"i",然后str指向i的内存地址
    实际上就是内存中有两个i对象，但是存放的地址不一样。

9.将字符串反转
10.String类常用的方法

11.抽象类必须有抽象方法么？
    抽象方法可以不包含抽象方法，包含抽象方法的一定是抽象类。

12.普通类与抽象类的区别？

13.抽象类能用final修饰么
    final不能修饰抽象类和接口，final修饰的类不能被继承。

14.接口与抽象类的区别
      抽象类是特殊的类，只是不能被实例化；除此以外，具有类的其他特性；重要的是抽象类可以包括抽象方法，
    这是普通类所不能的。抽象方法只能声明于抽象类中，且不包含任何实现，派生类必须覆盖它们。另外，抽象类
    可以派生自一个抽象类，可以覆盖基类的抽象方法也可以不覆盖，如果不覆盖，则其派生类必须覆盖它们。

      接口是抽象方法的集合。如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法。这就像契约模式，
    如果实现了这个接口，那么就必须确保使用这些方法。接口只是一种形式，接口自身不能做任何事情

    1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量
    必须指向实现所有接口方法的类对象。
    2、抽象类要被子类继承，接口要被类实现。
    3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现
    4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。
    5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。
    同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。
    6、抽象方法只能申明，不能实现，接口是设计的结果 ，抽象类是重构的结果
    7、抽象类里可以没有抽象方法
    8、如果一个类里有抽象方法，那么这个类只能是抽象类
    9、抽象方法要被实现，所以不能是静态的，也不能是私有的。
    10、接口可继承接口，并可多继承接口，但类只能单根继承。

    1.抽象类 和 接口 都是用来抽象具体对象的. 但是接口的抽象级别最高
    2.抽象类可以有具体的方法 和属性,  接口只能有抽象方法和不可变常量
    3.抽象类主要用来抽象类别,接口主要用来抽象功能.
    4.抽象类中，且不包含任何实现，派生类必须覆盖它们。接口中所有方法都必须是未实现的。

15.java中IO流分为几种
    Java中的流分为两种，一种是字节流，另一种是字符流，

    分别由四个抽象类来表示（每种流包括输入和输出两种所以一共四个）:InputStream，OutputStream，Reader，Writer。
    InputStream和OutputStream:两个是为字节流设计的,主要用来处理字节或二进制对象,
    Reader和Writer:两个是为字符流（一个字符占两个字节）设计的,主要用来处理字符或字符串.
    Java中其他多种多样变化的流均是由它们派生出来的.

    字符流处理的单元为2个字节的Unicode字符，操作字符、字符数组或字符串，
    字节流处理单元为1个字节，操作字节和字节数组。
    所以字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的，
    所以它对多国语言支持性比较好！
    如果是音频文件、图片、歌曲，就用字节流好点，
    如果是关系到中文（文本）的，用字符流好点

    所有文件的储存是都是字节（byte）的储存，在磁盘上保留的并不是文件的字符而是先把字符编码成字节，再储存这些字节到磁盘。在读取文件（特别是文本文件）时，也是一个字节一个字节地读取以形成字节序列
    字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串；
    字节流提供了处理任何类型的IO操作的功能，但它不能直接处理Unicode字符，而字符流就可以
    字节流是最基本的，所有的InputStrem和OutputStream的子类都是,主要用在处理二进制数据，它是按字节来处理的
    但实际中很多的数据是文本，
    又提出了字符流的概念，
    它是按虚拟机的encode来处理，也就是要进行字符集的转化
    这两个之间通过 InputStreamReader,OutputStreamWriter来关联，
    实际上是通过byte[]和String来关联
    在实际开发中出现的汉字问题实际上都是在字符流和字节流之间转化不统一而造成的


    Reader类的read()方法返回类型为int ：作为整数读取的字符（占两个字节共16位），范围在 0 到 65535 之间 (0x00-0xffff)，
    如果已到达流的末尾，则返回 -1

    字节流和字符流的主要区别是什么呢？
        一.字节流在操作时不会用到缓冲区（内存），是直接对文件本身进行操作的。而字符流在操作时使用了缓冲区，
        通过缓冲区再操作文件。
        二.在硬盘上的所有文件都是以字节形式存在的（图片，声音，视频），而字符值在内存中才会形成。

        上面两点能说明什么呢？
        针对第一点，
        我们知道，如果一个程序频繁对一个资源进行IO操作，效率会非常低。此时，通过缓冲区，先把需要操作的数据
        暂时放入内存中，以后直接从内存中读取数据，则可以避免多次的IO操作，提高效率
        针对第二点，
        真正存储和传输数据时都是以字节为单位的，字符只是存在与内存当中的，所以，字节流适用范围更为宽广

16.BIO、NIO、AIO的区别
    BIO：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，
    如果这个线程不做任何事情会造成不必要的线程开销。用于连接数量小且固定的架构。在此种方式下，用户进程发起一
    个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行,JAVA传统的IO模型属于此
    种方式。

    NIO：同步非阻塞，服务器实现模式为一个请求一个线程，客户端发送的连接请求都会注册到多路复用器上，多路复用器
    轮询到连接有io请求时才启动一个线程进行处理，适用于连接比较多，比较短的架构。在此种方式下，用户进程发起一
    个IO操作以后可返回做其他事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，
    从而引入不必要的CPU资源浪费，目前JAVA的NIO就属于同步非阻塞IO。

    AIO:异步非阻塞，一个有效请求一个线程，适用于链接数目多且长的架构。在此种方式下，用户进程只需要发起一个IO
    操作然后立即返回，等IO操作真正的完成以后，用户进程会得到IO操作完成的通知，此时用户进程只需要对数据进行
    处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了，
    目前Java中还没有支持此种IO模型。

17.Files的常用方法
    方法名       返回类型    说明
    getName()    String      获取文件名称
    canReade()   boolean     判断file是否可读
    canWrite()   boolean     判断file是否可写
    exists()     boolean     判断file是否存在
    length()     Long        获取file长度
    getAbsolutePath() String 获取file的绝对路径